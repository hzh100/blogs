<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>模块化背景 | blog</title>
    <meta name="description" content="vue、js、nodejs等等的学习记录">
    <link rel="stylesheet" href="/assets/style.49eed234.css">
    <link rel="modulepreload" href="/assets/Home.ae65bc00.js">
    <link rel="modulepreload" href="/assets/app.d95e124d.js">
    <link rel="modulepreload" href="/assets/js_前端模块化.md.ed11c518.lean.js">
    
    <meta name="twitter:title" content="模块化背景 | blog">
  <meta property="og:title" content="模块化背景 | blog">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme"><header class="nav-bar" data-v-675d8756><div class="sidebar-button" data-v-675d8756><svg class="icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z" class></path></svg></div><a class="nav-bar-title" href="/" aria-label="blog, back to home" data-v-675d8756 data-v-cc01ef16><!----> blog</a><div class="flex-grow" data-v-675d8756></div><div class="nav" data-v-675d8756><nav class="nav-links" data-v-675d8756 data-v-eab3edfe><!--[--><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item isExternal" href="https://gitee.com/hzh100" target="_blank" rel="noopener noreferrer" data-v-b8818f8c>gitee <svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-b8818f8c><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div><!--]--><!----><!----></nav></div><!--[--><!--]--></header><aside class="sidebar" data-v-83e92a68><nav class="nav-links nav" data-v-83e92a68 data-v-eab3edfe><!--[--><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item isExternal" href="https://gitee.com/hzh100" target="_blank" rel="noopener noreferrer" data-v-b8818f8c>gitee <svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-b8818f8c><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div><!--]--><!----><!----></nav><!--[--><!--]--><ul class="sidebar-links" data-v-83e92a68><!--[--><li class="sidebar-link"><p class="sidebar-link-item"> 介绍</p><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="/">介绍</a><!----></li></ul></li><li class="sidebar-link"><p class="sidebar-link-item">http</p><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="/http/http2">http2</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/http/http3">http3</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/http/http缓存">http缓存</a><!----></li></ul></li><li class="sidebar-link"><p class="sidebar-link-item">innermanage</p><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="/innermanage/内管前端工程">内管前端工程</a><!----></li></ul></li><li class="sidebar-link"><p class="sidebar-link-item">interview</p><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="/interview/JS基础">JS基础</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/interview/TODO">TODO</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/interview/前端面试之道">前端面试之道</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/interview/各种题目01">各种题目01</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/interview/手写系列-callbind">手写系列-callbind</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/interview/手写系列-instanceof">手写系列-instanceof</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/interview/手写系列-map和filter和reduce">手写系列-map和filter和reduce</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/interview/手写系列-new原理">手写系列-new原理</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/interview/手写系列-setTime模拟setInterval">手写系列-setTime模拟setInterval</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/interview/手写系列-发布订阅和观察者">手写系列-发布订阅和观察者</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/interview/手写系列-复杂axios">手写系列-复杂axios</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/interview/手写系列-复杂promise">手写系列-复杂promise</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/interview/手写系列-数组转树">手写系列-数组转树</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/interview/手写系列-深拷贝">手写系列-深拷贝</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/interview/手写系列-防抖节流">手写系列-防抖节流</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/interview/算法01">算法01</a><!----></li></ul></li><li class="sidebar-link"><p class="sidebar-link-item">jiagou</p><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="/jiagou/monorepo">monorepo</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/jiagou/从0到1构建符合标准的公共库">从0到1构建符合标准的公共库</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/jiagou/切换主题方案">切换主题方案</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/jiagou/前端基础建设与架构30讲">前端基础建设与架构30讲</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/jiagou/搭建组件库">搭建组件库</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/jiagou/深入babel">深入babel</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/jiagou/自动生成按需导出目录">自动生成按需导出目录</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/jiagou/表单组件带校验功能">表单组件带校验功能</a><!----></li></ul></li><li class="sidebar-link"><p class="sidebar-link-item">js</p><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="/js/class和构造函数">class和构造函数</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/js/dayFormat正则的使用">dayFormat正则的使用</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/js/luhn算法">luhn算法</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/js/Object.entries">Object.entries</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/js/proxy">proxy</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/js/优雅的Class">优雅的Class</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item active" href="/js/前端模块化">前端模块化</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#模块化背景">模块化背景</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#模块化方案环境支持">模块化方案环境支持</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#commonjs">CommonJs</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#从0实现简易commonjs">从0实现简易Commonjs</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#commonjs获取动态值">Commonjs获取动态值</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#关于commonjs的require是动态引用">关于Commonjs的require是动态引用</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#不用exports-xx-而是exports-xx-来存储变量会怎样">不用exports.xx=&#39;&#39; 而是exports={xx:&#39;&#39;} 来存储变量会怎样</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#es-module">ES Module</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#node环境">node环境</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#浏览器环境">浏览器环境</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#esm识别的资源路径">ESM识别的资源路径</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#接收的是动态的值">接收的是动态的值</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#esm自动严格模式">ESM自动严格模式</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#编译时、运行时、静态化">编译时、运行时、静态化</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#esm的编译时">ESM的编译时</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#cjs的运行时">CJS的运行时</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#nodejs中共用两种模块化方式会怎样">nodejs中共用两种模块化方式会怎样</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#esm可以运行时的import">ESM可以运行时的import()</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#es6与commonjs的区别">ES6与CommonJS的区别</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#esm的限制与解决方案">esm的限制与解决方案</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#代码需要基于es开发">代码需要基于es开发</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#第三方资源的导出要支持esm">第三方资源的导出要支持ESM</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#不支持esm的浏览器">不支持esm的浏览器</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#思考">思考</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#_1-webpack工程下怎么同时支持commonjs和esm规范">1. webpack工程下怎么同时支持CommonJs和ESM规范</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#_2-babel如何把esm编译成commonjs，在node环境中运行">2. babel如何把esm编译成commonjs，在node环境中运行</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#_3-webpack、rollup是怎么支持tree-shaking">3. webpack、rollup是怎么支持tree shaking</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#参考资料">参考资料</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="/js/浏览器垃圾回收">浏览器垃圾回收</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/js/深入babel">深入babel</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/js/闭包与垃圾回收">闭包与垃圾回收</a><!----></li></ul></li><li class="sidebar-link"><p class="sidebar-link-item">microFrontend</p><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="/microFrontend/介绍">介绍</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/microFrontend/拟定微前端架构设计">拟定微前端架构设计</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/microFrontend/架构思想">架构思想</a><!----></li></ul></li><li class="sidebar-link"><p class="sidebar-link-item">node</p><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="/node/cheetah-learn">cheetah-learn</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/node/cli相关学习">cli相关学习</a><!----></li></ul></li><li class="sidebar-link"><p class="sidebar-link-item">performance</p><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="/performance/serviceWorker">serviceWorker</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/performance/ssr">ssr</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/performance/慕课网web性能优化">慕课网web性能优化</a><!----></li></ul></li><li class="sidebar-link"><p class="sidebar-link-item">typescript</p><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="/typescript/vue2加ts">vue2加ts</a><!----></li></ul></li><li class="sidebar-link"><p class="sidebar-link-item">vue</p><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="/vue/create-vue脚手架">create-vue脚手架</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/vue/esbuild使用">esbuild使用</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/vue/keep-alive原理">keep-alive原理</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/vue/vue-router实现原理">vue-router实现原理</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/vue/模板编译">模板编译</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/vue/路由页面历史栈的处理">路由页面历史栈的处理</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/vue/重学vue-01模板语法">重学vue-01模板语法</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/vue/重学vue-02数据驱动视图">重学vue-02数据驱动视图</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/vue/重学vue-03render函数">重学vue-03render函数</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/vue/重学vue-04内置指令">重学vue-04内置指令</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/vue/重学vue-05filter多余吗">重学vue-05filter多余吗</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/vue/重学vue-06computer">重学vue-06computer</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/vue/重学vue-07watch">重学vue-07watch</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/vue/重学vue-08组件">重学vue-08组件</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/vue/重学vue-09生命周期">重学vue-09生命周期</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/vue/重学vue-10ref是什么">重学vue-10ref是什么</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/vue/重学vue-11nextTick">重学vue-11nextTick</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/vue/重学vue-8组件通信">重学vue-8组件通信</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/vue/重学vue-vue.use">重学vue-vue.use</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/vue/重学vue-动画内置组件">重学vue-动画内置组件</a><!----></li></ul></li><li class="sidebar-link"><p class="sidebar-link-item">vue3</p><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="/vue3/elementPlus">elementPlus</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/vue3/入门">入门</a><!----></li></ul></li><li class="sidebar-link"><p class="sidebar-link-item">webComponents</p><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="/webComponents/1. webComponent介绍">1. webComponent介绍</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/webComponents/2. customElements">2. customElements</a><!----></li></ul></li><li class="sidebar-link"><p class="sidebar-link-item">webpack</p><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="/webpack/1">1</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/webpack/实现一个自己的脚手架">实现一个自己的脚手架</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/webpack/重学webpack-01打包工具的思考">重学webpack-01打包工具的思考</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/webpack/重学webpack-02模块化原理">重学webpack-02模块化原理</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/webpack/重学webpack-03loader">重学webpack-03loader</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/webpack/重学webpack-04plugin">重学webpack-04plugin</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/webpack/重学webpack-05HMR热更新">重学webpack-05HMR热更新</a><!----></li></ul></li><li class="sidebar-link"><p class="sidebar-link-item">week</p><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="/week/202110-1">202110-1</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/week/202110-2">202110-2</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/week/202111-1">202111-1</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/week/缓存工具方法思路">缓存工具方法思路</a><!----></li></ul></li><li class="sidebar-link"><p class="sidebar-link-item">work</p><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="/work/ios小白条问题">ios小白条问题</a><!----></li></ul></li><!--]--></ul><!--[--><!--]--></aside><div class="sidebar-mask"></div><main class="page" data-v-7eddb2c4><div class="container" data-v-7eddb2c4><!--[--><!--]--><div style="position:relative;" class="content" data-v-7eddb2c4><div><iframe src="//player.bilibili.com/player.html?aid=208982494&amp;bvid=BV1jh411t7eX&amp;cid=435896955&amp;page=1" width="100%" height="300px" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p>完整视频系列及倍数请移步 <a href="https://space.bilibili.com/100023688" target="_blank" rel="noopener noreferrer">bilibili</a></p><h2 id="模块化背景" tabindex="-1">模块化背景 <a class="header-anchor" href="#模块化背景" aria-hidden="true">#</a></h2><blockquote><p>在现代前端工程里面，我们离不开打包工具，比如说 <a href="https://webpack.docschina.org/concepts/" target="_blank" rel="noopener noreferrer">webpack</a>、<a href="https://www.rollupjs.com/" target="_blank" rel="noopener noreferrer">rollup</a>、<a href="https://cn.vitejs.dev/guide/" target="_blank" rel="noopener noreferrer">vite</a></p></blockquote><p>那么我们为什么要用到打包工具呢? 原因之一是：在浏览器支持 ES 模块之前，前端没有原生支持以模块化的方式开发 js。打包工具的出现也是为了帮助开发让浏览器支持的模块化方案。</p><p>那不使用模块化开发的体验会是什么样子呢？</p><ul><li>容易造成变量污染(无意声明相同变量造成使用时不是预期变量)</li><li>js文件之间有依赖关系时，因为不能在js中引js，只能统一写到script引入，需要注意顺序问题。而且被依赖的js一般不希望被其他js调用，script只能全局引入，所有js都能调用不需要引用</li><li>开发无法分块编写，将项目分成更小的独立部分，是跟优雅的开发模式，更好维护代码和更好的复用。</li></ul><p>这也是<code>“打包”</code>这个概念出现的原因：使用打包工具抓取收集依赖资源、处理成script或是其他形式链接资源文件到引用方文件中，实现模块化。</p><blockquote><p>接下来将主要讲解 <code>Commonjs、ES Module</code> 模块化并且不会讲基础使用，其他如 <code>AMD、UMD</code> 可能提及但不会细讲，感兴趣请自行搜索🔍学习</p></blockquote><h2 id="模块化方案环境支持" tabindex="-1">模块化方案环境支持 <a class="header-anchor" href="#模块化方案环境支持" aria-hidden="true">#</a></h2><p>开发环境（<code>nodejs</code>）</p><ul><li>支持<code>Commonjs</code></li><li>ES6后通过<code>.mjs</code>支持 <code>ES Module</code></li></ul><p>浏览器环境</p><ul><li>不支持 <code>Commonjs</code></li><li>ES6后支持 <code>ES Module</code></li></ul><h2 id="commonjs" tabindex="-1">CommonJs <a class="header-anchor" href="#commonjs" aria-hidden="true">#</a></h2><blockquote><p>Commonjs是一种模块化规范(思想)</p></blockquote><p><code>Commonjs</code> 是一种规范并不是一种具体的代码，类似 <code>promise A+</code> 规范，只要符合规范里所有的条件，那它就是 <code>Commonjs</code>。</p><p>而nodejs就是借鉴这种思想实现自己的模块化的，所以也不能完全说nodejs就是 <code>Commonjs</code></p><blockquote><p>AMD模块化同样脱胎于Commonjs规范，浏览器支持的Commonjs一般是使用require.js的库，注意这个库和nodejs的require不是一个东西，这个库的Commonjs是AMD实现的。</p></blockquote><p>为了解决变量污染的问题，Commonjs规定每一个js都是独立的模块，即依赖的文件没有抛出的变量，是无法获到的。可以看作每个文件都是一个闭包。</p><blockquote><p>另外，<code>webpack</code>作为以nodejs为底层语言(强调这个是因为<a href="https://esbuild.github.io/" target="_blank" rel="noopener noreferrer">ESbuild</a>以<a href="https://www.topgoer.com/" target="_blank" rel="noopener noreferrer">GO</a>为底层语言)的打包工具，是依靠nodejs的Commonjs做依赖收集进行整合后用方法插入script来协助打包的。所以webpack工程下，编写Commonjs不需要额外支持，可以直接编译识别。-- TODO: 这里补一个文章跳转各种打包工具的模块化原理</p></blockquote><h3 id="从0实现简易commonjs" tabindex="-1">从0实现简易Commonjs <a class="header-anchor" href="#从0实现简易commonjs" aria-hidden="true">#</a></h3><h4 id="_0-前期准备" tabindex="-1">0. 前期准备 <a class="header-anchor" href="#_0-前期准备" aria-hidden="true">#</a></h4><p>开始前先转变以前的固有印象，<code>“引入”</code>和<code>“抛出”</code></p><p>在Commonjs</p><ul><li><code>引入</code>的本质是存储/缓存</li><li><code>抛出</code>的本质是读取缓存</li></ul><p>实现模块化的本质就是，把每个文件存储到<code>Modules</code>的大对象中，每个文件就是一个子对象<code>module</code>，且每个文件<code>module对象</code>内有各种信息</p><p>打印module和Module</p><div class="language-js"><pre><code><span class="token keyword">const</span> Module <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span>module<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token string">&#39;&#39;</span><span class="token punctuation">,</span>
    <span class="token literal-property property">exports</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token literal-property property">loaded</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
    <span class="token literal-property property">module</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token operator">...</span>
    <span class="token operator">...</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token operator">...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>抛出的内容就是往对象里的<code>exports</code>存储深拷贝的值，引入就是获取整个<code>exports</code>（一般解构赋值取出来使用）</p><p>由此可以看出一个 <code>Commonjs</code> 的特性：引入(也就是获取缓存)的值取决于当时存储时的值，也就不是动态可变的了</p><h4 id="_1-让js文件直接支持myexport、myrequire等" tabindex="-1">1. 让js文件直接支持myexport、myrequire等 <a class="header-anchor" href="#_1-让js文件直接支持myexport、myrequire等" aria-hidden="true">#</a></h4><p>支持Commonjs的环境(nodejs)，会在编译运行js时(运行 <code>node xx.js</code> )包装js</p><p>即我们写的js不是最终执行的js，而是会被包裹起来，进行统一处理</p><p>如 <code>node index.js</code> ，执行index.js，nodejs就会先对index.js进行包装</p><p>注入进去<code>export、models</code>等变量或函数</p><p>这就是在js里全局支持使用export的原因</p><p>接下来手写实现一个 <code>Commonjs</code>模块化，不会使用nodejs模块化相关的api，但是还是需要用到nodejs其他的api来帮助我们实现，如读取文件内容的 <code>fs</code>，遇到不会的<a href="http://nodejs.cn/api/" target="_blank" rel="noopener noreferrer">nodejs API</a>请自行搜索🔍学习</p><p>由👆分析，我们需要读取require引入的资源文件内容，进行包装并且注入模块化api或其他工具方法</p><div class="language-js"><pre><code><span class="token comment">// 包装js文件 注入api的期望方式</span>
<span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token function">wrap</span><span class="token punctuation">(</span>fileContent<span class="token punctuation">)</span><span class="token punctuation">(</span>myrequire<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 柯里化函数方式，第一次调用传递引入的资源文件内容，返回一个函数，传递要注入的东西并运行</span>
<span class="token punctuation">}</span>
</code></pre></div><p>👆包装js文件 注入api的期望方式</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">wrap</span><span class="token punctuation">(</span><span class="token parameter">fileContent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 拼接函数进行包装 注意要包一层()才不会被eval立即执行,而是返回一个字符串()内的函数</span>
  <span class="token keyword">const</span> newfileContent <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">(function (myrequire){
    </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>fileContent<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">
  })</span><span class="token template-punctuation string">`</span></span>
  <span class="token keyword">return</span> <span class="token function">eval</span><span class="token punctuation">(</span>newfileContent<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>👆 资源文件内容是一个js文件的所有字符串，里面可以直接使用模块化api 先包装字符串，然后执行，注意执行字符串的结果要返回一个函数而不是直接执行(会报错myrequire undefined)</p><div class="language-js"><pre><code><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">requuire</span><span class="token punctuation">(</span><span class="token string">&#39;fs&#39;</span><span class="token punctuation">)</span>
<span class="token keyword">function</span> <span class="token function">myrequire</span><span class="token punctuation">(</span><span class="token parameter">filePath</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;开始引入&#39;</span><span class="token punctuation">,</span>filePath<span class="token punctuation">)</span>
  <span class="token keyword">let</span> fileContent<span class="token punctuation">;</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    fileContent <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span>filePath<span class="token punctuation">,</span><span class="token string">&#39;utf8&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">没有找到引用资源</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>filePath<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>fileContent<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token function">wrap</span><span class="token punctuation">(</span>fileContent<span class="token punctuation">)</span><span class="token punctuation">(</span>myrequire<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">myrequire</span><span class="token punctuation">(</span><span class="token string">&#39;./index.js&#39;</span><span class="token punctuation">)</span>
</code></pre></div><p>这样就能运行引入的资源文件了，但是还没实现模块化抛出和接收的动作</p><div class="language-js"><pre><code><span class="token comment">// index.js</span>
<span class="token function">myrequire</span><span class="token punctuation">(</span><span class="token string">&#39;./a.js&#39;</span><span class="token punctuation">)</span>
<span class="token function">myrequire</span><span class="token punctuation">(</span><span class="token string">&#39;./b.js&#39;</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">lof</span><span class="token punctuation">(</span><span class="token string">&#39;执行index.js&#39;</span><span class="token punctuation">)</span>

<span class="token comment">// b.js</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;执行b.js&#39;</span><span class="token punctuation">)</span>

<span class="token comment">// 没有a.js</span>
</code></pre></div><p>打印内容会发现执行顺序</p><div class="language-js"><pre><code>开始引入index<span class="token punctuation">.</span>js
执行index<span class="token punctuation">.</span>js
开始引入a<span class="token punctuation">.</span>js
开始引入b<span class="token punctuation">.</span>js
没有找到a<span class="token punctuation">.</span>js
执行b<span class="token punctuation">.</span>js
</code></pre></div><p>可以看到，index.js引入a和b，执行index并没有等a和b引入结束</p><p>而运行一次原生Commonjs如下</p><div class="language-js"><pre><code>开始引入index<span class="token punctuation">.</span>js
开始引入a<span class="token punctuation">.</span>js
error 没有找到a<span class="token punctuation">.</span>js
</code></pre></div><p>原生是会等a和b引入结束才执行index的，并且遇到引入异常会中断运行</p><blockquote><p><code>Commonjs</code> 模块化是同步加载的</p></blockquote><p>我们自己写的 <code>Commonjs</code> 不是同步的原因是fs读取文件内容的api <code>fs.readFile()</code> 用了异步加载</p><div class="language-js"><pre><code><span class="token comment">// 读取文件内容是异步的，外面调用myrequire是不会等内部异步结束</span>
<span class="token comment">// 所以读取文件内容要用同步</span>
fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span>filePath<span class="token punctuation">)</span>
fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span>filePath<span class="token punctuation">)</span>
</code></pre></div><p>并且处理读取文件内容失败，要中断nodejs运行，抛出错误<code>throw</code> 改造后的 <code>myrequire()</code></p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">myrequire</span><span class="token punctuation">(</span><span class="token parameter">filePath</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;开始引入&#39;</span><span class="token punctuation">,</span>filePath<span class="token punctuation">)</span>
  <span class="token keyword">let</span> fileContent<span class="token punctuation">;</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    fileContent <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span>filePath<span class="token punctuation">,</span><span class="token string">&#39;utf8&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">没有找到引用资源</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>filePath<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>fileContent<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token function">wrap</span><span class="token punctuation">(</span>fileContent<span class="token punctuation">)</span><span class="token punctuation">(</span>myrequire<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="_2-myrequire识别资源方式" tabindex="-1">2. myrequire识别资源方式 <a class="header-anchor" href="#_2-myrequire识别资源方式" aria-hidden="true">#</a></h4><p>识别资源路径的几种格式</p><ul><li>xxx node内置模块</li><li>/xxx 当前目录绝对路径</li><li>./ ../ 当前目录相对路径</li><li>xxx node_modules下的目录</li></ul><div class="language-js"><pre><code><span class="token comment">/**
 * 文件路径几种格式
 * xxx node内置模块
 * /xxx 当前目录绝对路径
 * ./ ../ 当前目录相对路径
 * xxx node_modules下的目录
 */</span>
<span class="token keyword">const</span> enterPublicPath <span class="token operator">=</span> <span class="token string">&#39;example&#39;</span>
<span class="token keyword">function</span> <span class="token function">dealFilePath</span><span class="token punctuation">(</span><span class="token parameter">filePath</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> firstString <span class="token operator">=</span> filePath<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 路径首字符</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>firstString <span class="token operator">===</span> <span class="token string">&#39;.&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 当前目录相对路径转为绝对路径(模拟的都是从example中引入的，跟当前core文件夹是同级所以相对路径也是)</span>
    <span class="token comment">// console.log(&#39;当前文件core的绝对路径&#39;,__dirname);</span>
    <span class="token keyword">return</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">../</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>enterPublicPath<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>filePath<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>firstString <span class="token operator">===</span> <span class="token string">&#39;/&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 当前目录绝对路径</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>node内置模块<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>filePath<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// node内置模块</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// node_module模块</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>👆这里仿照webpack定义一个 <code>publicPath</code>，用于处理相对路径时的公共路径前缀，配合我们把代码抽离到core文件夹和在expample文件夹运行</p><p>关于资源路径属于 <code>node_module</code>的情况，会逐级查找资源，如下规则，这里不做实现</p><ul><li>在当前目录下的 node_modules 目录查找。</li><li>如果没有，在父级目录的 node_modules 查找，如果没有在父级目录的父级目录的 node_modules 中查找。</li><li>沿着路径向上递归，直到根目录下的 node_modules 目录。</li><li>在查找到第三方模块后，会找 <code>package.json</code> 下 main 属性指向的文件，如果没有 <code>package.json</code> ，在 nodejs 环境下会依次查找 <code>index.js ，index.json ，index.node</code>。</li></ul><p>改造后 <code>myrequire()</code></p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">myrequire</span><span class="token punctuation">(</span><span class="token parameter">filePath</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;开始引入&#39;</span><span class="token punctuation">,</span>filePath<span class="token punctuation">)</span>
  <span class="token keyword">const</span> newPath <span class="token operator">=</span> <span class="token function">dealFilePath</span><span class="token punctuation">(</span>filePath<span class="token punctuation">)</span> <span class="token comment">// 处理资源路径</span>
  <span class="token keyword">let</span> fileContent
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    fileContent <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span>newPath<span class="token punctuation">,</span><span class="token string">&#39;utf8&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">没有找到引用资源</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>newPath<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>fileContent<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token function">wrap</span><span class="token punctuation">(</span>fileContent<span class="token punctuation">)</span><span class="token punctuation">(</span>myrequire<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="_3-require处理资源防止套娃引用" tabindex="-1">3. require处理资源防止套娃引用 <a class="header-anchor" href="#_3-require处理资源防止套娃引用" aria-hidden="true">#</a></h4><p>reuqire顺序是深度优先遍历</p><blockquote><p>这里的深度优先并不是模块化工具在做递归，而是资源引用的写法：每次在不同文件下<code>require</code>，因为是同步执行自然而然形成的嵌套调用</p></blockquote><p>index引用a、b，a文件引用b，b文件引用a，node原生Commonjs执行顺序</p><div class="language-js"><pre><code>开始引入index<span class="token punctuation">.</span>js
开始引入a<span class="token punctuation">.</span>js 
开始引入b<span class="token punctuation">.</span><span class="token function">js</span> <span class="token punctuation">(</span>b有引a<span class="token punctuation">,</span>但是不会触发开始引入和执行a<span class="token punctuation">)</span>
执行b<span class="token punctuation">.</span>js
执行a<span class="token punctuation">.</span>js
执行index<span class="token punctuation">.</span>js
</code></pre></div><p>可以看出不会重复引用</p><p>实现原理：和递归遍历类似，可以用一个weakmap或者一个变量存储调用过的资源文件，因为做引入抛出也是存储的时候要用到Modules的变量，所以直接用一个Modules存储引用过的文件,把资源路径作为数组id存储</p><div class="language-js"><pre><code><span class="token keyword">const</span> Modules <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 做全局变量</span>

<span class="token keyword">function</span> <span class="token function">cacheModule</span><span class="token punctuation">(</span><span class="token parameter">filePath</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> isExist <span class="token operator">=</span> Modules<span class="token punctuation">.</span><span class="token function">some</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token operator">=&gt;</span>item<span class="token punctuation">.</span>id <span class="token operator">===</span> filePath<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>isExist<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Modules<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token literal-property property">id</span><span class="token operator">:</span> filePath
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> isExist<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>改造后 <code>myrequire()</code></p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">myrequire</span><span class="token punctuation">(</span><span class="token parameter">filePath</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;开始引入&#39;</span><span class="token punctuation">,</span>filePath<span class="token punctuation">)</span>
  <span class="token keyword">const</span> newPath <span class="token operator">=</span> <span class="token function">dealFilePath</span><span class="token punctuation">(</span>filePath<span class="token punctuation">)</span>
  <span class="token keyword">const</span> isExist <span class="token operator">=</span> <span class="token function">cacheModule</span><span class="token punctuation">(</span>newPath<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 判断是否加载过</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>isExist<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">// 加载过不再重复加载</span>
  <span class="token keyword">let</span> fileContent
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    fileContent <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span>newPath<span class="token punctuation">,</span><span class="token string">&#39;utf8&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">没有找到引用资源</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>newPath<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>fileContent<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token function">wrap</span><span class="token punctuation">(</span>fileContent<span class="token punctuation">)</span><span class="token punctuation">(</span>myrequire<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="_4-引用和抛出变量" tabindex="-1">4. 引用和抛出变量 <a class="header-anchor" href="#_4-引用和抛出变量" aria-hidden="true">#</a></h4><p>抛出和接收是使用模块化编程时的直观感受 实际上“抛出”的动作是文件把值存到export里 而“接收”就是require去export对象中取值(require还有抓取、包装文件内容的作用) 前面提到引用和抛出的本质是存储和获取，且每次加载资源都有一个数组存储资源的信息，我们往Modules全局变量中存储相应要抛出的变量即可</p><div class="language-js"><pre><code><span class="token keyword">const</span> Modules <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">function</span> <span class="token function">cacheModule</span><span class="token punctuation">(</span><span class="token parameter">filePath</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> isExist <span class="token operator">=</span> Modules<span class="token punctuation">.</span><span class="token function">some</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token operator">=&gt;</span>item<span class="token punctuation">.</span>id <span class="token operator">===</span> filePath<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>isExist<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Modules<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token literal-property property">id</span><span class="token operator">:</span> filePath<span class="token punctuation">,</span>
      <span class="token literal-property property">exports</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 加一个存储变量的地方</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> isExist<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>原生nodejs的Commonjs的使用方法是：</p><div class="language-js"><pre><code>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">a</span><span class="token operator">:</span><span class="token string">&#39;&#39;</span>
<span class="token punctuation">}</span>

exports<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token string">&#39;&#39;</span>
</code></pre></div><p>👆这里两种存储变量的形式，本质都是往全局变量Modules里的exports进行存储，因此两者使用的区别，请在实现之后自行思考，本质区别就是操作对象赋值的区别而已</p><p>我们往js里注入方法的时候只注入了myrequire，这次再往里注入module和exports</p><div class="language-js"><pre><code><span class="token comment">// myrequire() 的注入变量代码片段</span>

<span class="token keyword">const</span> index <span class="token operator">=</span> Modules<span class="token punctuation">.</span><span class="token function">findIndex</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token operator">=&gt;</span>item<span class="token punctuation">.</span>id<span class="token operator">===</span>newPath<span class="token punctuation">)</span>
<span class="token comment">// 注入多两个变量 module 和 exports</span>
<span class="token function">wrap</span><span class="token punctuation">(</span>fileContent<span class="token punctuation">)</span><span class="token punctuation">(</span>myrequire<span class="token punctuation">,</span>Modules<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">,</span>Modules<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>exports<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>👆这样我们实现了资源文件的存储变量，接下来要实现获取存储的变量，也就是在<code>myrequire()</code>之后返回出资源存储的整个对象exports即可</p><p>改造后 <code>myrequire()</code></p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">myrequire</span><span class="token punctuation">(</span><span class="token parameter">filePath</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;开始引入&#39;</span><span class="token punctuation">,</span>filePath<span class="token punctuation">)</span>
  <span class="token keyword">const</span> newPath <span class="token operator">=</span> <span class="token function">dealFilePath</span><span class="token punctuation">(</span>filePath<span class="token punctuation">)</span>
  <span class="token keyword">const</span> isExist <span class="token operator">=</span> <span class="token function">cacheModule</span><span class="token punctuation">(</span>newPath<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>isExist<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> fileContent <span class="token operator">=</span> <span class="token keyword">null</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    fileContent <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span>newPath<span class="token punctuation">,</span><span class="token string">&#39;utf8&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">没有找到引用资源</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>newPath<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 注入 存储用的两个变量 module 和 exports</span>
  <span class="token keyword">const</span> index <span class="token operator">=</span> Modules<span class="token punctuation">.</span><span class="token function">findIndex</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token operator">=&gt;</span>item<span class="token punctuation">.</span>id<span class="token operator">===</span>newPath<span class="token punctuation">)</span>
  <span class="token function">wrap</span><span class="token punctuation">(</span>fileContent<span class="token punctuation">)</span><span class="token punctuation">(</span>myrequire<span class="token punctuation">,</span>Modules<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">,</span>Modules<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>exports<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 返回资源文件存储的变量exports</span>
  <span class="token keyword">return</span> Modules<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>exports
<span class="token punctuation">}</span>
</code></pre></div><h4 id="_5-整理" tabindex="-1">5. 整理 <a class="header-anchor" href="#_5-整理" aria-hidden="true">#</a></h4><p>至此，我们已经从0到1实现了一个简易版的 <code>Commonjs</code></p><p>并且由此可知几个<strong>Commonjs的特性：</strong></p><ul><li><strong>加载资源是同步加载的</strong>，即如果资源很大还是会阻塞后面资源的加载</li><li>资源套娃引用或重复引用，<strong>不会重复加载</strong></li><li><strong>exports抛出的变量是值的拷贝</strong>，取决于加载资源时进行存储的变量是什么，后续不会更新存储的变量(即抛出的值是静态的)</li><li>执行require，会加载<strong>资源存储的所有变量</strong>到本文件</li></ul><h3 id="commonjs获取动态值" tabindex="-1">Commonjs获取动态值 <a class="header-anchor" href="#commonjs获取动态值" aria-hidden="true">#</a></h3><div class="language-js"><pre><code><span class="token comment">// lib.js</span>
<span class="token keyword">var</span> counter <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">changeCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  counter<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">getCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> counter
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  changeCounter<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>这样就可以拿到深拷贝的值，因为并不是拿拷贝的值，而是通过函数作用域去取值，作用域内的值变了，取到值就变了。</p><h3 id="关于commonjs的require是动态引用" tabindex="-1">关于Commonjs的require是动态引用 <a class="header-anchor" href="#关于commonjs的require是动态引用" aria-hidden="true">#</a></h3><blockquote><p>Commonjs的<code>require()</code>发生在运行时 首先明确一点，动态的概念不等于异步的概念</p></blockquote><p>动态引用是在条件作用域里require，只有在调用该函数才会运行引用资源，运行时才去获取对应的内容</p><p>而动态引用分两种情况</p><ul><li>不需要执行就已知资源路径的情况</li><li>需要执行才知道资源路径的情况 如:</li></ul><div class="language-js"><pre><code><span class="token comment">// 1.不需要执行就已知资源路径的情况</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
  <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;./a.js&#39;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span>


<span class="token comment">// 2.需要执行才知道资源路径的情况</span>
<span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> filePath <span class="token operator">=</span> x<span class="token punctuation">;</span>
  <span class="token function">require</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">onclick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token function">a</span><span class="token punctuation">(</span><span class="token string">&#39;./a.js&#39;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在webpack里require的资源是个未知的变量（运行时才可知）的话，上线之后会加载不到该文件。为什么nodejs可以加载，webpack不行？</p><blockquote><p>是因为在本地node环境下，动态require运行时可以找到文件，如果动态require的文件是本地不存在的话，也是会像webpack一样报错找不到的 而webpack打包不会运行未知的代码(会收集已知的require资源),所以不会知道动态require的文件是什么，就不会把目标文件打包进项目，最后运行时服务器中找不到该文件就会报错</p></blockquote><p>关于异步加载： 希望点击才加载a文件，在Commonjs里，index依赖a即使在条件作用域里，也必须初始化的时候就加载进来，点击时只是获取并执行a，并不是点击时才去找a文件进行加载和执行</p><h3 id="不用exports-xx-而是exports-xx-来存储变量会怎样" tabindex="-1">不用exports.xx=&#39;&#39; 而是exports={xx:&#39;&#39;} 来存储变量会怎样 <a class="header-anchor" href="#不用exports-xx-而是exports-xx-来存储变量会怎样" aria-hidden="true">#</a></h3><blockquote><p><code>module.exports = {}</code>、<code>exports.xx=&#39;&#39;</code> 同样是操作exports存储对象，那可不可以<code>exports = {}</code>呢？</p></blockquote><p>我们知道exports的来源是注入到函数里的形参 也就是👇的形式：</p><div class="language-js"><pre><code><span class="token keyword">const</span> exports <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token literal-property property">a</span><span class="token operator">:</span><span class="token string">&#39;a&#39;</span><span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token parameter">exports</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  exports <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token literal-property property">b</span><span class="token operator">:</span><span class="token string">&#39;b&#39;</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">a</span><span class="token punctuation">(</span>exports<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>exports<span class="token punctuation">)</span> <span class="token comment">// {a:&#39;a&#39;}</span>
</code></pre></div><p>👆函数的引用类型形参做重新赋值，在函数体中将会是个新的变量，而不是外部的变量 是js原生这么干的，不关nodejs的<code>Commonjs机制</code>的事</p><p>在require中，exports是文件资源信息对象里的一个属性，如果在文件中自己重新赋值了exports，因为一个文件就是一个单独的作用域函数，exports将是一个作用域下全新的变量，而不再是外部文件对象里的属性，那么require就取不到文件抛出的信息了</p><p xx="">这也就是为什么抛出数据只能exports.xx 一个个抛出(存储)而不能直接exports =</p><div class="language-js"><pre><code><span class="token keyword">const</span> module <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">myexports</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token literal-property property">a</span><span class="token operator">:</span><span class="token string">&#39;1&#39;</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 传入的是module.myexports引用类型，如果重新赋值了myexports将不再有引用作用而是一个新的对象</span>
<span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token parameter">myexports</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  myexports <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token literal-property property">a</span><span class="token operator">:</span><span class="token string">&#39;2&#39;</span><span class="token punctuation">}</span> <span class="token comment">// --&gt;{ myexports: {a:&#39;1&#39;} }</span>
  <span class="token comment">// myexports.b = &#39;b&#39; // --&gt;{ myexports: {b: &#39;b&#39;} }</span>
<span class="token punctuation">}</span>
<span class="token function">a</span><span class="token punctuation">(</span>module<span class="token punctuation">.</span>myexports<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>module<span class="token punctuation">)</span> <span class="token comment">// --&gt;{ myexports: {a:&#39;1&#39;} }</span>
</code></pre></div><h2 id="es-module" tabindex="-1">ES Module <a class="header-anchor" href="#es-module" aria-hidden="true">#</a></h2><h3 id="node环境" tabindex="-1">node环境 <a class="header-anchor" href="#node环境" aria-hidden="true">#</a></h3><p><code>node 8.5</code>开始支持mjs，但是还是实验性的所以需要参数<code>--experimental-modules</code> 执行.mjs 会提示ESM是实验性</p><div class="language-bash"><pre><code><span class="token function">node</span> --experimental-modules index.mjs
<span class="token punctuation">(</span>node:9076<span class="token punctuation">)</span> ExperimentalWarning: The ESM module loader is experimental.
</code></pre></div><p><code>node13</code>开始不需要实验参数,可以直接执行.mjs .mjs可以用ESM，并且还是支持原来Commonjs</p><h3 id="浏览器环境" tabindex="-1">浏览器环境 <a class="header-anchor" href="#浏览器环境" aria-hidden="true">#</a></h3><blockquote><p>和node环境用mjs后缀的方式不同，在浏览器环境不认识mjs，mjs是node自己新增的</p></blockquote><p>浏览器需要不影响以往的没有模块化的js，所以要支持模块化时在<code>&lt;srcipt&gt;</code>标签加上type</p><h4 id="script标签的async、defer" tabindex="-1">script标签的async、defer <a class="header-anchor" href="#script标签的async、defer" aria-hidden="true">#</a></h4><p>在讲<code>type=module</code>之前，我们看看其他属性 默认scipt标签都是同步加载，即按顺序加载script标签并会阻塞后面的加载 浏览器提供scipt识别为需要异步加载资源<code>async、defer、module</code>都是异步加载的</p><div class="language-html"><pre><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>./1.js<span class="token punctuation">&quot;</span></span> <span class="token attr-name">defer</span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>./2.js<span class="token punctuation">&quot;</span></span> <span class="token attr-name">async</span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><ul><li><code>defer</code>要等到整个页面在内存中正常渲染结束（<code>DOM</code> 结构完全生成，以及其他脚本执行完成），才会执行(即使已经下载完成了)</li><li><code>async</code>一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再恢复渲染</li></ul><p>浏览器的V8引擎，渲染页面和执行js是共用一个线程的，所以会交错执行如👆<code>async</code>的场景。</p><p><code>defer</code>是“渲染完再执行”，<code>async</code>是“下载完就执行”。另外，如果有多个defer脚本，会按照它们在页面出现的顺序加载，而多个<code>async</code>脚本是不能保证加载顺序的。</p><h4 id="type-module" tabindex="-1">type=module <a class="header-anchor" href="#type-module" aria-hidden="true">#</a></h4><p>因为<code>type=&quot;module&quot;</code>默认就是异步加载的，所以也要有个异步规则，那就是<code>defer</code> 所以👇其实就是一种省略默认值的写法</p><div class="language-html"><pre><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>module<span class="token punctuation">&quot;</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>./1.js<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token comment">&lt;!-- 等同于 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>module<span class="token punctuation">&quot;</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>./1.js<span class="token punctuation">&quot;</span></span> <span class="token attr-name">defer</span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>和<code>defer</code>基本相同，等页面渲染结束，才按顺序执行资源(即使已经下载完资源)</p><p>而如果是<code>async</code></p><div class="language-html"><pre><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>module<span class="token punctuation">&quot;</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>./1.js<span class="token punctuation">&quot;</span></span> <span class="token attr-name">async</span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>则会是一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再恢复渲染，并且不保证顺序</p><p>由👆<code>type=&quot;module&quot;</code>，更多的是让文件内部可以使用ESM模块化，控制异步规则还是靠<code>defer、async</code><code>ES Module</code>除了加载规则跟异步加载资源相同外，内部是支持直接使用import的。而这是只开启异步加载的资源文件无法做到的</p><h3 id="esm识别的资源路径" tabindex="-1">ESM识别的资源路径 <a class="header-anchor" href="#esm识别的资源路径" aria-hidden="true">#</a></h3><p>回忆一下 <code>Commonjs</code>识别资源的路径有<code>相对路径</code>、<code>绝对路径</code>、<code>nodejs内置模块</code>、<code>node_module第三方资源</code></p><p>那ESM的资源路径：<code>相对路径</code>、<code>绝对路径</code>、<code>第三方资源URl</code></p><p><code>import</code>第三方资源只能引用<code>完整的 URL</code>，相对以前的裸导入 (bare import specifiers)(人话就是直接通过模块名导入)，很不太方便，如下例:</p><div class="language-js"><pre><code><span class="token keyword">import</span> lodash <span class="token keyword">from</span> <span class="token string">&#39;lodash&#39;</span>
</code></pre></div><p>它不同于 Node.JS 可以依赖系统文件系统，层层寻找 <code>node_modules</code></p><p>在 ESM 中，可通过 <code>importmap</code> 使得裸导入可正常工作:</p><div class="language-html"><pre><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>importmap<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token punctuation">{</span>
  <span class="token string-property property">&quot;imports&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token string-property property">&quot;lodash&quot;</span><span class="token operator">:</span> <span class="token string">&quot;https://cdn.sykpack.dev/lodash&quot;</span><span class="token punctuation">,</span>
    <span class="token string-property property">&quot;ms&quot;</span><span class="token operator">:</span> <span class="token string">&quot;https://cdn.sykpack.dev/ms&quot;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>lodash<span class="token punctuation">&quot;</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>module<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>加了上面的map，浏览器就支持通过别名直接引入模块了</p><p>补充一点：平时可以到这里 <a href="https://npm.devtool.tech/" target="_blank" rel="noopener noreferrer">https://npm.devtool.tech/</a> 查看各种第三方包的cdn，看看别人的导出方式 👇浏览器的控制台可以直接使用ESM的CDN</p><div class="language-js"><pre><code><span class="token operator">&gt;</span> lodash <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">&#39;https://cdn.skypack.dev/lodash&#39;</span><span class="token punctuation">)</span>

<span class="token operator">&gt;</span> lodash<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">&#39;a&#39;</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="接收的是动态的值" tabindex="-1">接收的是动态的值 <a class="header-anchor" href="#接收的是动态的值" aria-hidden="true">#</a></h3><div class="language-js"><pre><code><span class="token keyword">export</span> <span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token string">&#39;bar&#39;</span><span class="token punctuation">;</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> foo <span class="token operator">=</span> <span class="token string">&#39;baz&#39;</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>上面代码输出变量 foo ，值为 bar ，500 毫秒之后变成 baz 。</p><p>这一点与 CommonJS 规范完全不同。CommonJS 模块输出的是值的缓存，不存在动态更新(如果是引用类型也不行，因为是运行时进行存储的值的拷贝)</p><h3 id="esm自动严格模式" tabindex="-1">ESM自动严格模式 <a class="header-anchor" href="#esm自动严格模式" aria-hidden="true">#</a></h3><p>ES6 的模块自动采用严格模式，不管你有没有在模块头部加上<code>&quot;use strict&quot;</code>;。</p><p>严格模式主要有以下限制:</p><ul><li>变量必须声明后再使用</li><li>函数的参数不能有同名属性，否则报错</li><li>不能使用with语句</li><li>不能对只读属性赋值，否则报错</li><li>不能使用前缀 0 表示八进制数，否则报错</li><li>不能删除不可删除的属性，否则报错</li><li>不能删除变量delete prop，会报错，只能删除属性delete global[prop]</li><li><code>eval</code>不会在它的外层作用域引入变量</li><li><code>eval</code>和<code>arguments</code>不能被重新赋值</li><li>arguments不会自动反映函数参数的变化</li><li>不能使用arguments.callee</li><li>不能使用arguments.caller</li><li>禁止this指向全局对象</li><li>不能使用fn.caller和fn.arguments获取函数调用的堆栈</li><li>增加了保留字（比如protected、static和interface）</li></ul><p>其中，尤其需要注意this的限制。ES6 模块之中，顶层的<code>this</code>指向<code>undefined</code>，即不应该在顶层代码使用this。</p><p>👇因此利用顶层的 <code>this</code> 等于 <code>undefined</code> 这个语法点，可以侦测当前代码是否在 <code>ES6</code> 模块之中。</p><div class="language-js"><pre><code><span class="token keyword">const</span> isNotModuleScript <span class="token operator">=</span> <span class="token keyword">this</span> <span class="token operator">!==</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="编译时、运行时、静态化" tabindex="-1">编译时、运行时、静态化 <a class="header-anchor" href="#编译时、运行时、静态化" aria-hidden="true">#</a></h2><ul><li>ESM发生在编译时且是静态化的</li><li>CJS发生在运行时</li></ul><p>编译时报错是语法/句法错误 运行时报错是各种情况 👆平时可以留意一下两种报错的区别</p><blockquote><p>ES6 模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及抛出和接收的变量</p></blockquote><h3 id="esm的编译时" tabindex="-1">ESM的编译时 <a class="header-anchor" href="#esm的编译时" aria-hidden="true">#</a></h3><p>编译时：如 <code>import</code> 命令是编译阶段执行的，即在代码运行之前。 编译过程不能使用表达式和变量，表达式和变量是只有在运行时才能得到的动态结果</p><p><strong>因为ESM是命令式语法，因此不做源码解读和伪代码的编写，请彻底理解👇发生在编译时的模块化原理</strong></p><p>编译流程是：</p><blockquote><p>JS 引擎对脚本静态分析的时候，遇到命令 <code>import</code> ，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的文件里面去取值（由于 <code>ES6 import</code>的变量，只是一个<code>“符号连接(指针)”</code>，所以这个变量是只读的，相当于“抛出”的变量都是const，对它进行重新赋值会报错。</p></blockquote><blockquote><p>浏览器通过html的<code>&lt;script type=&quot;module&quot;&gt;</code>,加载第一个js，这个js是入口文件 后续模块都是js中的import，而不是浏览器中的<code>&lt;script&gt;</code></p></blockquote><blockquote><p>浏览器加载文件的功能我们称为加载器，加载器开始加载文件时，会把文件路径作为key记录到模块映射(缓存)中 不等文件加载完成，标记为加载中。继续开始下一个文件。 加载完成后触发解析文件即<code>编译</code>，识别静态语法中import。继续触发加载器，以此形成了一种深度遍历的效果，不过是不等待的那种 有了模块映射(缓存)，加载器就可以跳过加载重复模块，直接导出模块的运行结果 另外，导出值的引用是在递归加载文件之后执行的，即会到最深层再往上抛出的顺序导出值的引用</p></blockquote><p>ES6 模块“抛出”的变量是活的，ES6 模块是动态取值，并不是通过存储值来做抛出</p><div class="language-js"><pre><code><span class="token keyword">import</span> <span class="token punctuation">{</span>a<span class="token punctuation">,</span>b<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;fs&#39;</span>`
</code></pre></div><p>👆不是函数，是js语法支持的读取命令，且命令实现只读取fs文件中抛出的a和b，并且这里的<code>{ }</code>并不是解构赋值，而是命令解析的字符串。</p><p>另外<code>import</code> 不能写在条件代码块之中，没法做静态优化了，违背了 ES6 模块的设计初衷</p><div class="language-js"><pre><code><span class="token comment">// 报错</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">===</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">import</span> MyModual <span class="token keyword">from</span> <span class="token string">&#39;./myModual&#39;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>编译过程处理 import 语句，这时不会去分析或执行 if 语句，所以 import 语句放在 if 代码块之中毫无意义，报句法错误，而不是执行时错误</p><h3 id="cjs的运行时" tabindex="-1">CJS的运行时 <a class="header-anchor" href="#cjs的运行时" aria-hidden="true">#</a></h3><p><code>CommonJS</code> 和 <code>AMD</code> 模块化，都只能在运行时确定模块的依赖关系，以及抛出和接收的变量 如Commonjs</p><div class="language-js"><pre><code><span class="token keyword">const</span> <span class="token punctuation">{</span>a<span class="token punctuation">,</span>b<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;fs&quot;</span><span class="token punctuation">)</span>`
</code></pre></div><p>上面讲原理的时候也讲到，<code>rqeuire</code>是个函数，是运行函数才能读取资源的，并且只能整个文件的存储都读取下来，再解构赋值给a和b</p><h3 id="nodejs中共用两种模块化方式会怎样" tabindex="-1">nodejs中共用两种模块化方式会怎样 <a class="header-anchor" href="#nodejs中共用两种模块化方式会怎样" aria-hidden="true">#</a></h3><p>通过 Babel 转码，CommonJS 模块的 require 命令和 ES6 模块的 import 命令，可以写在同一个文件里面，但是最好不要这样做。因为import 在静态解析阶段执行，所以它是一个模块之中最早执行的，出现不按代码顺序执行的情况：</p><div class="language-js"><pre><code><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;core-js/modules/es6.symbol&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;core-js/modules/es6.promise&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">&#39;React&#39;</span><span class="token punctuation">;</span>
</code></pre></div><p><code>core-js/modules</code>是给react实例化用的插件，需要在react之前加载好，但是这样写会先实例化react</p><h2 id="esm可以运行时的import" tabindex="-1">ESM可以运行时的import() <a class="header-anchor" href="#esm可以运行时的import" aria-hidden="true">#</a></h2><p><code>import()</code> 函数可以用在任何地方。它是运行时执行，什么时候运行到这一句，也会加载指定的模块。另外，<code>import()</code> 函数与所加载的模块没有静态连接关系（人话就是import()不会返回指定变量，而是返回整个文件的输出），这点也是与 <code>import</code> 语句不相同。</p><p><code>import()</code> 类似于 <code>nodejs</code> 的 <code>require</code> 方法，区别主要是前者是异步加载，后者是同步加载（就是require一定会加载结束才往下走，而import()不await住的话会异步执行）</p><blockquote><p>所以nodejs环境 <code>Commonjs</code>可以被<code>await import()</code>完全替代了？</p></blockquote><h2 id="es6与commonjs的区别" tabindex="-1">ES6与CommonJS的区别 <a class="header-anchor" href="#es6与commonjs的区别" aria-hidden="true">#</a></h2><ul><li>CommonJS 模块输出的是一个值的拷贝(深拷贝)</li><li>ES6 模块输出的是值的引用（变量的指针）</li><li></li><li>CommonJS 模块是运行时加载</li><li>ES6 模块是编译时输出接口</li></ul><p><strong>ESM对工程化最大的好处是浏览器直接支持模块化代码的编写</strong> 如下依靠ESM不安装任何依赖直接使用react框架，</p><div class="language-js"><pre><code><span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">&quot;module&quot;</span><span class="token operator">&gt;</span>
  <span class="token keyword">import</span> <span class="token punctuation">{</span> html<span class="token punctuation">,</span> Component<span class="token punctuation">,</span> render <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;https://unpkg.com/htm/preact/standalone.module.js&#39;</span><span class="token punctuation">;</span>
  <span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>
    state <span class="token operator">=</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">0</span>
    <span class="token punctuation">}</span>
    <span class="token function-variable function">add</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> html<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
        &lt;div class=&quot;app&quot;&gt;
          &lt;div&gt;count: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&lt;/div&gt;
          &lt;button onClick=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>add<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&gt;Add Todo&lt;/button&gt;
        &lt;/div&gt;
      </span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token function">render</span><span class="token punctuation">(</span>html<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>App<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> page=&quot;All&quot; /&gt;</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span> document<span class="token punctuation">.</span>body<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre></div><h2 id="esm的限制与解决方案" tabindex="-1">esm的限制与解决方案 <a class="header-anchor" href="#esm的限制与解决方案" aria-hidden="true">#</a></h2><h3 id="代码需要基于es开发" tabindex="-1">代码需要基于es开发 <a class="header-anchor" href="#代码需要基于es开发" aria-hidden="true">#</a></h3><h3 id="第三方资源的导出要支持esm" tabindex="-1">第三方资源的导出要支持ESM <a class="header-anchor" href="#第三方资源的导出要支持esm" aria-hidden="true">#</a></h3><p>第三方资源node_module或者CDN的模块要可以通过import加载到</p><h3 id="不支持esm的浏览器" tabindex="-1">不支持esm的浏览器 <a class="header-anchor" href="#不支持esm的浏览器" aria-hidden="true">#</a></h3><p>不支持esm的浏览器会跳过<code>type=module</code>的js 这时再html写多一个<code>bundle.js</code> <code>commonjs规范</code>的代码资源兼容即可 浏览器提供一个标签属性<code>&lt;script nomodule src=&quot;&quot;&gt;</code>会判断是否支持esm，不支持则加载该标签</p><p><a href="https://github.com/systemjs/systemjs" target="_blank" rel="noopener noreferrer">systemjs</a>实现兼容方案</p><div class="language-html"><pre><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>system.js<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>systemjs-importmap<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token punctuation">{</span>
  <span class="token string-property property">&quot;imports&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token string-property property">&quot;lodash&quot;</span><span class="token operator">:</span> <span class="token string">&quot;https://unpkg.com/lodash@4.17.10/lodash.js&quot;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>systemjs-module<span class="token punctuation">&quot;</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span><span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>加载这个库后，用type=&quot;systemjs-module&quot;，会根据浏览器支持esm的情况处理代码</p><h2 id="思考" tabindex="-1">思考 <a class="header-anchor" href="#思考" aria-hidden="true">#</a></h2><h3 id="_1-webpack工程下怎么同时支持commonjs和esm规范" tabindex="-1">1. webpack工程下怎么同时支持CommonJs和ESM规范 <a class="header-anchor" href="#_1-webpack工程下怎么同时支持commonjs和esm规范" aria-hidden="true">#</a></h3><p>提示：webpack通过编译(不等于上面说的js引擎的编译)CMD和ESM的源代码做资源收集合并，再利用js插入script的形式来做整合过的模块化</p><p>开发编写的是Commonjs和ESM，最后上线的代码既不是CMD也不是ESM，而是打包后的插入script方法(webpack干的)</p><h3 id="_2-babel如何把esm编译成commonjs，在node环境中运行" tabindex="-1">2. babel如何把esm编译成commonjs，在node环境中运行 <a class="header-anchor" href="#_2-babel如何把esm编译成commonjs，在node环境中运行" aria-hidden="true">#</a></h3><p><a href="https://www.imyangyong.com/blog/2020/11/javascript/Babel%20%E4%B9%8B%20ESM%20%E5%92%8C%20CommonJS/" target="_blank" rel="noopener noreferrer">Babel 之 ESM 和 CommonJS</a></p><h3 id="_3-webpack、rollup是怎么支持tree-shaking" tabindex="-1">3. webpack、rollup是怎么支持tree shaking <a class="header-anchor" href="#_3-webpack、rollup是怎么支持tree-shaking" aria-hidden="true">#</a></h3><p>提示：ESM因为命令式语法发生在编译时根据指针接收变量，即本身就是不引入额外的变量，也就是不需要做<code>tree shaking</code>这个动作，但是打包工具最终上线的不是ESM，且即使代码写的CJS，上线后也能实现<code>tree shaking</code></p><hr><h2 id="参考资料" tabindex="-1">参考资料 <a class="header-anchor" href="#参考资料" aria-hidden="true">#</a></h2><ul><li><a href="https://jakearchibald.com/2017/es-modules-in-browsers/" target="_blank" rel="noopener noreferrer">ECMAScript modules in browsers</a></li><li><a href="https://zhuanlan.zhihu.com/p/26567790" target="_blank" rel="noopener noreferrer">JavaScript 模块现状</a></li><li><a href="https://github.com/developit/htm" target="_blank" rel="noopener noreferrer">基于esm、html、unpkg的前端开发模式</a></li><li><a href="https://timdaub.github.io/2021/01/16/web-principles/" target="_blank" rel="noopener noreferrer">How I Build JavaScript Apps In 2021</a></li><li><a href="https://estimator.dev/" target="_blank" rel="noopener noreferrer">Find out how much turning on modern JS could save.</a></li><li><a href="https://zhuanlan.zhihu.com/p/96718777" target="_blank" rel="noopener noreferrer">什么是amd、commonjs、umd、esm?</a></li><li><a href="https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/" target="_blank" rel="noopener noreferrer">ES modules: A cartoon deep-dive</a></li><li><a href="https://github.com/WICG/import-maps" target="_blank" rel="noopener noreferrer">import.map</a></li><li><a href="https://topic.atatech.org/articles/202736" target="_blank" rel="noopener noreferrer">面对 ESM 的开发模式，webpack 还有还手之力吗?</a></li></ul></div></div><footer class="page-footer" data-v-7eddb2c4 data-v-fb8d84c6><div class="edit" data-v-fb8d84c6><div class="edit-link" data-v-fb8d84c6 data-v-1ed99556><!----></div></div><div class="updated" data-v-fb8d84c6><!----></div></footer><div class="next-and-prev-link" data-v-7eddb2c4 data-v-38ede35f><div class="container" data-v-38ede35f><div class="prev" data-v-38ede35f><a class="link" href="/js/优雅的Class" data-v-38ede35f><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon icon-prev" data-v-38ede35f><path d="M19,11H7.4l5.3-5.3c0.4-0.4,0.4-1,0-1.4s-1-0.4-1.4,0l-7,7c-0.1,0.1-0.2,0.2-0.2,0.3c-0.1,0.2-0.1,0.5,0,0.8c0.1,0.1,0.1,0.2,0.2,0.3l7,7c0.2,0.2,0.5,0.3,0.7,0.3s0.5-0.1,0.7-0.3c0.4-0.4,0.4-1,0-1.4L7.4,13H19c0.6,0,1-0.4,1-1S19.6,11,19,11z"></path></svg><span class="text" data-v-38ede35f>优雅的Class</span></a></div><div class="next" data-v-38ede35f><a class="link" href="/js/浏览器垃圾回收" data-v-38ede35f><span class="text" data-v-38ede35f>浏览器垃圾回收</span><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon icon-next" data-v-38ede35f><path d="M19.9,12.4c0.1-0.2,0.1-0.5,0-0.8c-0.1-0.1-0.1-0.2-0.2-0.3l-7-7c-0.4-0.4-1-0.4-1.4,0s-0.4,1,0,1.4l5.3,5.3H5c-0.6,0-1,0.4-1,1s0.4,1,1,1h11.6l-5.3,5.3c-0.4,0.4-0.4,1,0,1.4c0.2,0.2,0.5,0.3,0.7,0.3s0.5-0.1,0.7-0.3l7-7C19.8,12.6,19.9,12.5,19.9,12.4z"></path></svg></a></div></div></div><!--[--><!--]--></div></main></div><!----><!--]--></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"http_http2.md\":\"f913a313\",\"http_http3.md\":\"060f1a93\",\"http_http缓存.md\":\"31fc5d76\",\"index.md\":\"e233a088\",\"innermanage_内管前端工程.md\":\"e613f30e\",\"interview_js基础.md\":\"f3bc5865\",\"interview_todo.md\":\"199537bf\",\"interview__过.md\":\"865ff21e\",\"interview_前端面试之道.md\":\"ec1a40c2\",\"interview_各种题目01.md\":\"079c680b\",\"interview_手写系列-callbind.md\":\"12930746\",\"interview_手写系列-instanceof.md\":\"5ef6c309\",\"interview_手写系列-map和filter和reduce.md\":\"7d9d2352\",\"interview_手写系列-new原理.md\":\"a96cf990\",\"interview_手写系列-settime模拟setinterval.md\":\"e387ac1a\",\"interview_手写系列-发布订阅和观察者.md\":\"a516d630\",\"interview_手写系列-复杂axios.md\":\"ed7137b3\",\"interview_手写系列-复杂promise.md\":\"4e5735bb\",\"interview_手写系列-数组转树.md\":\"c01229aa\",\"interview_手写系列-深拷贝.md\":\"79f771f4\",\"interview_手写系列-防抖节流.md\":\"060f760c\",\"interview_算法01.md\":\"182a4137\",\"jiagou_monorepo.md\":\"51eb3439\",\"jiagou_从0到1构建符合标准的公共库.md\":\"99849ee2\",\"jiagou_切换主题方案.md\":\"501a1a5e\",\"jiagou_前端基础建设与架构30讲.md\":\"f7baf6ec\",\"jiagou_搭建组件库.md\":\"d9bc651d\",\"jiagou_深入babel.md\":\"9abe1423\",\"jiagou_自动生成按需导出目录.md\":\"5f601077\",\"jiagou_表单组件带校验功能.md\":\"d794d549\",\"js_object.entries.md\":\"3ba00128\",\"js_class和构造函数.md\":\"d5c78ad6\",\"js_dayformat正则的使用.md\":\"8abaaa7f\",\"js_luhn算法.md\":\"ffeffec6\",\"js_proxy.md\":\"a7b2ad3a\",\"js_优雅的class.md\":\"497ed7e9\",\"js_前端模块化.md\":\"ed11c518\",\"js_浏览器垃圾回收.md\":\"b6fa7d93\",\"js_深入babel.md\":\"92842df6\",\"js_闭包与垃圾回收.md\":\"bd9a10f4\",\"microfrontend_介绍.md\":\"9ff9f87d\",\"microfrontend_拟定微前端架构设计.md\":\"fccf143e\",\"microfrontend_架构思想.md\":\"748e5304\",\"node_cheetah-learn.md\":\"95e6fcd1\",\"node_cli相关学习.md\":\"c29bfdd7\",\"performance_serviceworker.md\":\"6f67fcf2\",\"performance_ssr.md\":\"0f412a14\",\"performance_慕课网web性能优化.md\":\"f53c24bc\",\"typescript_vue2加ts.md\":\"9d17aaa6\",\"vue_create-vue脚手架.md\":\"89f2fa24\",\"vue_esbuild使用.md\":\"7977b135\",\"vue_keep-alive原理.md\":\"ef31ebc9\",\"vue_vue-router实现原理.md\":\"6106cd66\",\"vue_模板编译.md\":\"50b03259\",\"vue_路由页面历史栈的处理.md\":\"8b4132c2\",\"vue_重学vue-01模板语法.md\":\"436fc3ef\",\"vue_重学vue-02数据驱动视图.md\":\"d89737de\",\"vue_重学vue-03render函数.md\":\"1cc2f4a1\",\"vue_重学vue-04内置指令.md\":\"59840a53\",\"vue_重学vue-05filter多余吗.md\":\"02057bf4\",\"vue_重学vue-06computer.md\":\"10c8a4d4\",\"vue_重学vue-07watch.md\":\"25d56e53\",\"vue_重学vue-08组件.md\":\"3d21f25c\",\"vue_重学vue-09生命周期.md\":\"786dacfb\",\"vue_重学vue-10ref是什么.md\":\"a29dd7e6\",\"vue_重学vue-11nexttick.md\":\"35043fa8\",\"vue_重学vue-8组件通信.md\":\"4845edc5\",\"vue_重学vue-vue.use.md\":\"cc4266d2\",\"vue_重学vue-动画内置组件.md\":\"04d4553c\",\"vue3_elementplus.md\":\"2f3aeef9\",\"vue3_入门.md\":\"33504c8d\",\"webcomponents_1. webcomponent介绍.md\":\"29a6407a\",\"webcomponents_2. customelements.md\":\"9e1088a3\",\"webpack_1.md\":\"7279a63f\",\"webpack__草稿.md\":\"39f16499\",\"webpack_实现一个自己的脚手架.md\":\"b4d5365f\",\"webpack_重学webpack-01打包工具的思考.md\":\"083571d8\",\"webpack_重学webpack-02模块化原理.md\":\"0650e76f\",\"webpack_重学webpack-03loader.md\":\"43789662\",\"webpack_重学webpack-04plugin.md\":\"73454000\",\"webpack_重学webpack-05hmr热更新.md\":\"007085b5\",\"week_202110-1.md\":\"ecb6af64\",\"week_202110-2.md\":\"59fce584\",\"week_202111-1.md\":\"7d3ac50a\",\"week__0todo.md\":\"d60b5fc0\",\"week_缓存工具方法思路.md\":\"13a83606\",\"work_ios小白条问题.md\":\"cf9e950f\"}")</script>
    <script type="module" async src="/assets/app.d95e124d.js"></script>
    
  </body>
</html>